nextflow_process {

    name "Test Process GENERATE_EXAMPLE_GENOTYPES_VCFS"
    script "modules/generate_example_genotypes_vcfs.nf"
    process "GENERATE_EXAMPLE_GENOTYPES_VCFS"

    /*
     * Test 1: Check accessibility of example 1000 Genomes VCFs
     */
    test("Should have accessible vcfs from 1000 Genomes") {

        when {
            def testUrls = [
                "https://ftp.1000genomes.ebi.ac.uk/vol1/ftp/release/20130502/ALL.chr1.phase3_shapeit2_mvncall_integrated_v5b.20130502.genotypes.vcf.gz",
                "https://ftp.1000genomes.ebi.ac.uk/vol1/ftp/release/20130502/ALL.chr22.phase3_shapeit2_mvncall_integrated_v5b.20130502.genotypes.vcf.gz",
                "https://ftp.1000genomes.ebi.ac.uk/vol1/ftp/release/20130502/ALL.chrX.phase3_shapeit2_mvncall_integrated_v1c.20130502.genotypes.vcf.gz"
            ]

            def failedUrls = []

            testUrls.each { url ->
                def cmd = "curl -I --fail --connect-timeout 10 --max-time 30 ${url}"
                def result = cmd.execute()
                result.waitFor()

                if (result.exitValue() == 0) {
                    println("‚úÖ URL accessible: ${url.split('/').last()}")
                } else {
                    println("‚ùå URL not accessible: ${url.split('/').last()}")
                    println("Error: ${result.err.text}")
                    failedUrls << url.split('/').last()
                }
            }

            this.failedUrls = failedUrls
        }

        then {
            assert this.failedUrls.isEmpty(), "The following URLs are not accessible: ${this.failedUrls.join(', ')}. Check your internet connection or if the 1000 Genome FTP server is down."
        }
    }

    /*
     * Test 2: Run the process in stub mode and verify VCF structure
     */
    test("Should run without failures - stub mode with >4500 variants") {

        options "-stub"

        when {
            params {
                outdir_vcfs = "test_results/vcfs"
            }
            process "GENERATE_EXAMPLE_GENOTYPES_VCFS"
        }

        then {
            assert process.success
            assert process.exitStatus == 0

            with(process.out.vcfs) {
                // The channel should have one element containing all files
                assert size() == 1 : "Expected 1 channel element but got ${size()}"

                def fileList = get(0)
                println "üîç File list size: ${fileList.size()}"

                assert fileList.size() == 23 : "Expected 23 files but got ${fileList.size()}"

                // Check each VCF for correct number of variants
                fileList.eachWithIndex { filePath, index ->
                    def file = path(filePath)
                    def variantCount = 0

                    new java.util.zip.GZIPInputStream(file.newInputStream()).withReader { reader ->
                        reader.eachLine { line ->
                            if (!line.startsWith('#')) {
                                variantCount++
                            }
                        }
                    }

                    println("üß¨ File ${index + 1}: ${file.fileName.toString()} - ${variantCount} variants")

                    assert variantCount == 4501 : "Expected 4501 variants in ${file.fileName.toString()} but found ${variantCount}"
                }
            }
        }
    }
}
